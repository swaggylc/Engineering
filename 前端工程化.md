# 前端工程化

定义：前端开发的管理工具

### 前端工程化的意义

#### 	为什么要学习前端工程化

#### 	架构师的职责

#### 	如何学习前端工程化

### 模块化与包管理

#### 	模块化(文件问题)

1. （分解）全局污染
2. （聚合）依赖混乱    

#### 	模块化标准

1. Common Js ：运行时，例如require语句可以写在if里，必须等代码运行时才能确定依赖关系
2. ESM：编译时，只能写在最顶部，在编译时即可确定依赖关系
3. AMD
4. CMD
5. UMD

#### 	什么是包

package：一系列模块的集合

#### 	包管理的组成部分

npm：包的属性：registry(仓库/源)、cli(命令行用户界面)

### JS工具链

#### JS语言的缺陷

#### 环境的兼容性问题

##### 	API兼容的处理办法

**polyfill(垫片、填充物)**：如果运行环境版本较低不支持高版本环境的函数，那我们需要去手动书写这么一个函数。现在一般依赖于**core-js**

##### 	语法兼容的处理办法

**syntax transformer/runtime(语法转换器/运行时)**：一个工具解决一个问题。例如async、awite

#### babel、babel preset

babel：代码转换/兼容/扩展的一系列流程

babel preset：预设，免去每一步的手动设置，例如下载不同的语法兼容工具等

#### 什么是 AST?

抽象语法树：babel将原始代码转换成抽象语法树，再将抽象语法树转换为兼容性好的，可运行的代码，在将抽象语法树转换为代码的过程中可以使用babel插件，从而达到个性化的需求。

#### SWC

对标babel，rust语言编写，转换速度更快

### css工具链

#### CSS语言的缺陷

语法缺失：循环、判断、拼接

功能缺失：颜色函数、数学函数、自定义函数

#### CSS 预编译器

sass/less/stylus --->预编译器 ----->  css

#### 后处理器

厂商前缀、代码压缩、代码剪枝：处理的是原生css问题(后处理器)

#### PostCSS  

处理转换逻辑：css--->parse--->plugin1--->plugin2--->stringifier--->new css

#### 原子化CSS

### 构建工具和脚手架

#### 开发和维护的代码应该是什么样?

开发/维护代码：vue语法、jsx、less、sass

#### 运行的代码应该是什么样?

运行代码：js、css、html

#### 构建工具的意义

开发工程---->构建工具---->运行工程

#### 常见构建工具

webpack、vite、rollup、esbuild

#### webpack的核心概念

1. **入口（Entry）**
    - 指示 Webpack 应该从哪个模块开始构建内部依赖图
    - 默认值是 `./src/index.js`，可以在配置文件中配置 `entry` 属性修改
2. **输出（Output）**
    - 告诉 Webpack 在哪里输出打包后的文件以及如何命名
    - 通过配置 `output` 属性指定，包括 `path`（输出路径）和 `filename`（文件名）
3. **loader**
    - 用于处理非 JavaScript 文件（如 CSS、图片、TypeScript 等）
    - 将这些文件转换为有效的模块，以便 Webpack 能够处理并将它们添加到依赖图中
    - 常见的 loader 有 `css-loader`、`babel-loader`、`file-loader` 等
4. **插件（Plugins）**
    - 用于执行范围更广的任务，如打包优化、资源管理、环境变量注入等
    - 插件需要 `require` 引入并添加到 `plugins` 数组中
    - 常见的插件有 `HtmlWebpackPlugin`、`CleanWebpackPlugin`、`DefinePlugin` 等
5. **模式（Mode）**
    - 提供内置优化，有 `development`、`production` 和 `none` 三种模式
    - `development` 模式下注重构建速度和开发体验
    - `production` 模式下自动启用各种优化，注重输出质量
    - 不设置时默认是 `production`
6. **模块（Module）**
    - Webpack 中一切皆模块，不仅限于 JavaScript 文件
    - 模块之间可以通过 `import`、`require` 等方式建立依赖关系
7. **chunk**
    - 代码分割的产物，是打包过程中生成的中间文件
    - 入口文件会生成一个 chunk，通过代码分割也会生成新的 chunk
8. **bundle**
    - 最终输出的文件，一个 bundle 可能由多个 chunk 组成
    - 通常是经过压缩、优化后的文件

#### webpack模块查找规则

路径查找：1、文件夹，找文件夹下的index.js

​					2、node查找规则，查找node_modules（当前层级没有则向上查找），再查找对应模块的package.json，再找main所对应的文件

#### 开发服务器

#### 热更新

Webpack 的热更新（Hot Module Replacement，简称 HMR）是开发环境中非常实用的功能，它允许在应用程序运行时替换、添加或删除模块，而无需完全刷新整个页面。这大大提高了开发效率，保留了应用程序的运行状态。

##### 热更新的工作原理

1. **Webpack 编译阶段**：在开发模式下，Webpack 会为每个模块添加热更新代码
2. **建立通信**：通过 WebSocket 或 HTTP 长轮询在浏览器和 Webpack 开发服务器之间建立连接
3. **文件变化检测**：当文件发生变化时，Webpack 重新编译变化的模块
4. **推送更新**：将更新的模块推送到浏览器端
5. **运行时替换**：浏览器端的 HMR 运行时替换旧模块，保持应用状态

#### 文件指纹在做什么?

防止打包文件更新后，浏览器还从缓存中获取旧的js代码

#### 源码地图在做什么?

根据运行时的代码找到源代码(开发代码)

#### 什么是脚手架?

提供界面与交互(命令行)

提供工程模板